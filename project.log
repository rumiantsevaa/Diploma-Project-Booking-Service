There will be listed Documentation of the Current Project Progress. 

09.12
A GitHub repository has been created: https://github.com/rumiantsevaa/Diploma-Project-Booking-Service.
Access has been configured for the team. The designer has been added to the project as a collaborator and can work in their own branch: /design.
A domain name for the website has been rented on the nic.ua portal bbooking.pp.ua. The domain is valid for one year.

10.12
Updated the domain’s Nameservers (NS) to Cloudflare’s to manage the domain through Cloudflare.
Added bbooking.pp.ua to Cloudflare, enabling performance, security, and encryption features.
Updated DNS records, including: A CNAME record for www.bbooking.pp.ua, pointing to rumiantsevaa.github.io, and set proxy status to Proxied for security.

Initially, the custom domain in GitHub Pages was set to bbooking.pp.ua. 
This setup led to DNS resolution issues due to GitHub's restrictions on using CNAME for the root domain (bbooking.pp.ua).
The solution was to change the custom domain to www.bbooking.pp.ua in GitHub Pages, as GitHub Pages can support a CNAME record for subdomains like www. 
This fixed the DNS issue and allowed proper routing of the custom domain.

The website is now accessible at https://www.bbooking.pp.ua/.
Cloudflare’s security and performance features are active, including HTTPS encryption.
GitHub Pages automatically builds and deploys the site whenever changes are made to the main branch on GitHub in the /docs folder, ensuring the site is always up to date with the latest changes.

11.12 
The website migration to AWS server.

12.12 
Nginx set up on AWS server.
SSL Certificates for both www.bbooking.pp.ua/ bbooking.pp.ua issued.

18.12
Manual NGINX REVERSE PROXY set up confugured in container with SSL Certification on AWS (volumes for copying added), Docker Compose manual build and deployment done. 
The general traffic flow will look like the following: Client -> NGINX -> WSGI -> Flask. Everything but certificates managed and set up inside the docker with external access via port forwarding. 
Proceed automation + Repository file structure migration. 

MAJOR PROJECT LOG UPDATE:

Current Status:
The website is fully operational and accessible at both https://bbooking.pp.ua and https://www.bbooking.pp.ua.
SSL enforcement is configured, ensuring all traffic is securely redirected to https:// with no access allowed via http://.
Both www and non-www segments are functional and properly routed to the application.

Deployment Process:
Deployment is now fully automated and tested. Changes pushed to the main branch on GitHub trigger the following steps:
*Connect to the AWS server via SSH.
*Stop any currently running Docker containers (without deletion).
*Sync repository files to the server.
*Rebuild services with docker compose build.
*Restart the application with docker compose up -d.

Changes to Security Configuration:
Cloudflare integration has been removed, including its security, performance, and DNS management features.
This decision was made to transition to a self-hosted protection mechanism, allowing greater flexibility and control over traffic and security measures.

Summary of Key Features:
*Fully automated deployment pipeline.
*Secure, SSL-enforced access to both www.bbooking.pp.ua and non-www bbooking.pp.ua domains (Redirects 80 => 443).
*Auto NGINX reverse proxy configuration within a Docker container for external SSL management.
*All critical components, except certificates, are handled inside Docker with external access enabled via port forwarding.

19.12
Certbot renewal is set up via crontab.

23.12
Deployment trigger:
* Fired when pushing to the main branch
* Ignores changes in the version.txt file
Main steps:
* Checkout code from the repository
* Login to Docker Hub using secret credentials
Versioning:
* Generates a new Docker tag based on semantic versioning
* Increments the patch version by 1
* Updates the version.txt file
* Creates a new git tag
* Pushes changes back to the repository
* Building and publishing Docker images:
* Builds a Flask application and pushes to Docker Hub
* Builds an Nginx image and pushes to Docker Hub
* Uses the new version for image tags
Deploy to AWS:
* Connects to an AWS server via SSH
* Creates/updates the project directory
* Clones/updates the code from the repository
* Gets the current version from version.txt
* Creates a .env file with current version
* Stops current containers
* Cleans unused images
* Pull new images
* Restart containers via docker compose
The entire process is automated and runs on every push to the main branch. This ensures continuous delivery (CD) of the application to the production server.

Added Personal Access Token to the Update version files block.
The token is used for authorization when pushing changes to a new version.txt file containing the version tag back to the repository: git push ...//${{ secrets.PAT }}.
----------------------------------------------------------------------------------------------------------------
! Why use PAT and not GITHUB_TOKEN?
GITHUB_TOKEN is automatically generated for each GitHub Actions run, but: * Limited to tasks inside Actions only.

PAT allows you to:
- Push changes and tags.
- Work with other repositories.
- Set access levels (e.g. read, write).
----------------------------------------------------------------------------------------------------------------
! Fixed infinite version update loop in GitHub Actions workflow by adding paths-ignore for version.txt in deploy.yml.
This improvement ensures that:
- Version updates only trigger on actual code changes
- Prevents recursive workflow triggers from version file updates
- Maintains clean versioning history
- Deployment automation continues to work as expected with version increments only on meaningful changes

The deployment process remains fully automated with the following workflow:
1. Code changes pushed to main branch trigger the workflow
2. New version tag is generated and version.txt is updated
3. Docker images are built and pushed with new version tags
4. AWS server deploys updated containers

--- DOCKER HUB LIMITATIONS OVERCOME --- 

Docker Hub does not support uploading a complete compose.yml file as a single entity. 

The project uses docker-compose.yaml to orchestrate two main services:
* nginx-proxy (Frontend proxy server)
* flask-app (Backend application)

The solution is to store compose.yml file in a version-controlled repository like GitHub and reference the individual images hosted on Docker Hub within that file.

Docker Hub and GitHub Integration:
! The project uses both Docker Hub and GitHub because:

* Docker images are stored on Docker Hub with versioning (using ${TAG} variable)
* Configuration files and application code need to be mounted/copied from GitHub:
  - /nginx/default.conf (Nginx configuration)
  - SSL certificates (/etc/letsencrypt)
  - Application code and requirements

Key files cloned from GitHub:
* Flask application: app.py (main application) - requirements.txt (dependencies)

* Nginx configuration: default.conf (server configuration) - nginx.conf (main configuration) - start.sh (initialization script)

Communication Flow: Client Request -> Nginx (443/80) -> Flask App (8000)

! Security Features:
- SSL/TLS encryption
- Automatic HTTP to HTTPS redirection
- Non-root users in containers
- Proper file permissions
- Health checks for both services

Deployment Process:
* Images are built and tagged with versions
* Both images are pushed to Docker Hub (serpentariya/booking_nginx and serpentariya/booking_app)
* During deployment, docker-compose pulls images from the Docker Hub and mounts necessary files from the cloned GitHub repository

This architecture allows for:
* Version control of both code and Docker images
* Secure SSL termination
* Proper separation of concerns between frontend proxy and application server
* Easy deployment and scaling
* Efficient resource utilization
_______________________________________________________________________________________________________
The split between Docker Hub (for images) and GitHub (for configuration and code) is necessary because:
_______________________________________________________________________________________________________
1. Docker Hub is optimized for storing and distributing container images
2. GitHub provides version control for configuration and code files
3. Some files (like SSL certificates) need to be mounted at runtime and shouldn't be baked into images
4. This separation allows for better security and maintenance practices

24.12 
deploy.yml changes: Deploy to AWS Job //
Removed git clone/pull to only copy the necessary files via scp due to the project structure.
The directory structure simplified - create only the necessary ones.
.
├── compose.yaml
└── nginx
    └── default.conf
2 directories, 2 files (needed for compose.yaml ( WHICH IS A CRUCIAL HANDLER to operate and maintain pulled from Docker Hub images that were built and uploaded in previous steps as requested.))

* Operations Left:
- Copying configuration files: compose.yaml and default.conf
- Creating .env with version
- Stopping old containers
- Cleaning unused images
- Loading new images
- Starting new containers

NOW I CAN OFFICIALLY ANNOUNCE : IT WORKS! WORKS! OPTIMIZED! OPTIMIZED!  
Current version is v1.0.27

25.12 
Docker and Docker Hub check and installation on AWS Server added.
Certificate paths optimized - now using a single SSL certificate for both domains (bbooking.pp.ua and www.bbooking.pp.ua). 
Previously, no-www domain was using a separate certificate, but now both domains are covered by one certificate, which simplifies management and improves efficiency. 
This is reflected in nginx/default.conf where both domains use the same certificate path:
ssl_certificate /etc/letsencrypt/live/www.bbooking.pp.ua/fullchain.pem
ssl_certificate_key /etc/letsencrypt/live/www.bbooking.pp.ua/privkey.pem 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*** SSL Certificate Management Automation Added to deploy.yml : *** 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
- Automated Certbot installation check and setup
- Automated crontab management (installation, enabling, and starting of cron service)
- Automated certificate renewal task configuration:
  * Sets up automatic renewal at 3 AM on the first day of each month
  * Replaces previous manual crontab setup from December 19th
- Implemented intelligent certificate handling:
  * Checks for existing certificate for both domains (bbooking.pp.ua and www.bbooking.pp.ua)
  * Automatically renews existing certificate when needed
  * Obtains new certificate if none exist(in case of server migration or project files corruption)
  * Manages Docker containers during certificate operations (stops before renewal, starts after)
  * Uses non-interactive mode with automated email configuration

♡ This automation eliminates the need for manual SSL certificate management and ensures consistent certificate handling across all deployments. 
♡ The system now automatically maintains SSL security without human intervention.




